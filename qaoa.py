# -*- coding: utf-8 -*-
"""QAOA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1loKty73FZJdzhNiC2pTfQ1P999DCwnvW
"""

!pip install qiskit==0.43
!pip install qiskit_aer
!pip install qiskit_algorithms
from qiskit_aer import Aer

import numpy as np
from itertools import product
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp
from qiskit.algorithms.minimum_eigensolvers import QAOA
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.primitives import Sampler

# Define problem parameters
num_positions = 22
num_symbols = 3  # Available Symbols {1,2,3}
window_size = 3  # Sliding Window

P_validity_values = [2,5,10, 20, 50]  # Penalty for validity
P_unique_values = [20,40,80, 100, 120, 140]  # Penalty for uniqueness
reps_values = [5,8]  # Number of repetitions in ansatz
optimizers = [COBYLA()]  # Different optimizers


# Best result tracker
best_score = float("inf")
best_params = None
best_sequence = None

# Grid search over hyperparameters
for P_validity, P_unique, reps, optimizer in product(P_validity_values, P_unique_values, reps_values, optimizers):
    # Construct Hamiltonian
    H_validity = SparsePauliOp.from_list([
         ("I" * i + "Z" + "I" * (num_positions - i - 1), P_validity) for i in range(num_positions)
     ])

    H_unique = SparsePauliOp.from_list([
         ("I" * i + "Z" + "I" * (j - i - 1) + "Z" + "I" * (num_positions - j - 1), P_unique)
         for i in range(num_positions - window_size + 1) for j in range(i + 1, i + window_size)
     ])

    H_total = H_unique + H_validity
    cost_operator = H_total  # Ensure cost operator is properly assigned
    # Define QAOA
    sampler = Sampler()
    qaoa = QAOA(sampler=sampler, optimizer=optimizer, reps=reps)

    # Solve problem
    result = qaoa.compute_minimum_eigenvalue(cost_operator)
    optimal_params = result.optimal_point

    # Decode solution
    def decode_solution(params):
        sequence = [(int(params[i]) % num_symbols) + 1 for i in range(min(len(params), num_positions))]
        return sequence

    final_sequence = decode_solution(optimal_params)

    # Evaluate the solution (minimizing the eigenvalue as score)
    score = result.optimal_value

    if score < best_score:
        best_score = score
        best_params = (P_validity, P_unique, reps, optimizer)
        best_sequence = final_sequence

    print(f"P_validity: {P_validity}, P_unique: {P_unique}, reps: {reps}, optimizer: {optimizer.__class__.__name__}")
    print("Generated Sequence:", final_sequence)
    print("Score:", score)
    print("-"*50)

# Print best configuration
print("Best Hyperparameters:", best_params)
print("Best Generated Sequence:", best_sequence)
print("Best Score:", best_score)