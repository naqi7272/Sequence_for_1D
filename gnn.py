# -*- coding: utf-8 -*-
"""GNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KAzJT9SM62rrPfnKVJfr9U1jc6Y0XZqC
"""

import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np

# Define the GNN Model
class GNN(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim):
        super(GNN, self).__init__()
        self.conv1 = nn.Linear(input_dim, hidden_dim)
        self.conv2 = nn.Linear(hidden_dim, output_dim)
        self.relu = nn.ReLU()

    def forward(self, x, adj):
        h = self.relu(self.conv1(x))
        h = torch.matmul(adj, h)  # Message Passing
        h = self.conv2(h)
        return torch.softmax(h, dim=1)

# Define parameters
num_positions = 12  # Number of nodes
num_symbols = 3  # Number of unique symbols
window_size = 3  # Enforce unique symbols per window

# One-hot encoding for input features
X = torch.eye(num_positions)

# Adjacency Matrix (Chain-like structure)
A = torch.diag(torch.ones(num_positions - 1), 1) + torch.diag(torch.ones(num_positions - 1), -1)

# Define the Loss Function with Window Constraint
def custom_loss(output, target, window_size):
    loss = nn.CrossEntropyLoss()(output, target)

    # Ensure uniqueness within window
    for i in range(num_positions - window_size + 1):
        window = target[i:i + window_size]
        if len(set(window.tolist())) < window_size:
            loss += 20.0  # Penalty for non-unique symbols

    return loss

# Initialize model
model = GNN(num_positions, 8, num_symbols)
optimizer = optim.Adam(model.parameters(), lr=0.001)
num_epochs = 50

# Training Loop
print("Training Progress:")
for epoch in range(num_epochs):
    optimizer.zero_grad()
    output = model(X, A)
    target = torch.randint(0, num_symbols, (num_positions,))
    loss = custom_loss(output, target, window_size)
    loss.backward()
    optimizer.step()

    # Print loss every 5 epochs
    if (epoch + 1) % 5 == 0:
        print(f"Epoch [{epoch + 1}/{num_epochs}], Loss: {loss.item():.4f}")

# Generate valid sequence ensuring uniqueness constraint
def generate_valid_sequence(model, X, A, window_size):
    raw_sequence = torch.argmax(model(X, A), dim=1) + 1
    valid_sequence = raw_sequence.clone()

    for i in range(num_positions - window_size + 1):
        while len(set(valid_sequence[i:i + window_size].tolist())) < window_size:
            valid_sequence[i] = (valid_sequence[i] % num_symbols) + 1

    return valid_sequence.numpy()

final_sequence = generate_valid_sequence(model, X, A, window_size)
print("\nGenerated Unique Sequence:", final_sequence)